# 微信支付

## 1.下单结构代码

### 1.目标

​     我们在使用微信扫码支付时，需要调用微信的下单接口，把需要的参数需要我们提前处理，比如签名sign, 随机字符串, 完成了之后，我们可以拿到下单接口返回核心内容```code_url``，我们根据```code_url```生成一张支付的二维码，给前端.

### 2.实现思路

1.koa项目中使用```axios```调用微信下单接口

2.按照下单接口需要的参数，我们把结构写出来



### 3.代码实现

​	 routes/order.js

```javascript
const router = require('koa-router')();

const { order } = require('../controller/order');
```


​    
```javascript
// 微信下单
router.post('/order', order);
```


​    
```javascript
module.exports = router;
```

controller/order.js

```javascript
const { default: axios } = require("axios")

// 微信下单
module.exports.order = async (ctx) =>{
    // 下单需要的参数
    const params = {
        appid,  
        mch_id,  // 商户号
        nonce_str, // 32位以内的随机字符串
        sign, // 签名
        body, // 商品描述
        out_trade_no, // 商户订单号
        total_fee, // 金额
        spbill_create_ip,  // 终端ip
        notify_url, // 微信服务器回调的地址
        trade_type,  // 支付类型
    }

    const data =  await createOrder(url, params);

    ctx.body = {
        status:200,
        data
    }
}
```



### 4.总结

1. 按照mvc结构新增order模块，在controller层调用微信下单， 把需要的参数准备好，下单单独在utils中封装一个下单方法



## 2.微信下单请求参数

### 1.目标

   我们需要把```appp_id, mch_id,  nonce_str```  下单其中三个参数搞定

### 2.实现思路

1. 为了安全考虑，把app_id, ```mch_id```  在后端存放
2. 在```utils```工具类中封装生成随机字符串的方法



### 3.代码实现

config/wx.js

```javascript
// appid
module.exports.app_id = 'wx8397f8696b538317';
// 商户号
module.exports.mch_id = '1473426802';



// 微信下单
module.exports.orderUrl = 'https://api.mch.weixin.qq.com/pay/unifiedorder';

```

utils/index.js

```javascript
// 生成32位以内的随机字符串,而且是不重复的
module.exports.getRandomStr = () =>{
 return  'letao' + this.getRandomByLength(6) + new Date().getTime();
}
```



### 4.总结

1. 较为敏感的数据，比如商户号，```appid```等这些数据，存放在后端,为了安全考虑，  要掌握随机数相关的操作，很多随机相关的业务，都基于随机数



## 3.签名算法

### 1.目标

我们需要按照微信下单接口中签名算法的要求，实现一个生成签名算法的方法。

### 2.实现思路

1. utils/index.js 封装一个```createSign ```方法 ，方法根据参数，返回一个32位的字符串
2. 需要拿到对象参数，拿到对象中的所有key按照数按照参数名ASCII码从小到大排序（字典序）
3. 返回字符串格式:   key1=value1&key2=value2…）拼接成字符串stringA。
4. 拿到拼接后的字符串 在拼接 key（商户后台）



### 3.代码实现

utils/index.js

```javascript
// 生成签名算法
module.exports.createSign = (args)=>{
    // 第一步，设所有发送或者接收到的数据为集合M，
    //  将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），
    // 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。
    let stringA = '';
    Object.keys(args).sort().forEach(key => {
        stringA += `${key} = ${args[key]}&`;
    });

    stringA += `&key=${key}`;

    return crypto.createHash('MD5').update(stringA).digest('hex').toUpperCase()

}  
```



#### 4.总结

​      1.请求参数对象按照把所有的key 进行sort排序， 转成key1=value1 & key2 = value2........

​      2.最后的结果在拼接key(商户后台中的key)

​      3.  拿到最终字符串进行MD5加密(crypto)



## 4.微信下单

### 1.目标

​    我们按照微信下单官网文档，调通微信下单

### 2.实现思路

  1.定义变量，存放xml格式的请求参数

  2.utils/index.js  创建订单方法，返回的数据也是xml格式， 我需要安装xml2js接受返回的数据

  3.在controller/order.js 中 调用 下单方法，拿到数据返回给客户端



### 3.代码实现

utils/index.js

```javascript
// 微信下单
module.exports.createOrder =(url, params) => {
    return new Promise(async (resolve, reject) => {
        const data = await axios({
            url,
            method: 'POST',
            data:params
        })
        // console.log(data, 'data');
        // resolve(data);
        xml.parseString(data.data, function (err, data){
             resolve(data);
        })
    });
}
```

controller/order.js

```javascript
// 微信下单
module.exports.order = async (ctx) =>{
    // 前端调用下单接口时传递的参数
    const { body,total_fee, spbill_create_ip,trade_type} = ctx.request.body;
    // 生成sign需要的参数
    const params = {
        appid,  
        mch_id,  // 商户号
        nonce_str: getRandomStr(), // 32位以内的随机字符串
        // sign, // 签名
        body, // 商品描述
        out_trade_no:getTrade_no(), // 商户订单号
        total_fee, // 金额
        spbill_create_ip,  // 终端ip
        notify_url, // 微信服务器回调的地址
        trade_type,  // 支付类型
    }

   // 生产签名  需要你发送的参数生成
   const sign =  createSign(params);
   //微信下单请求参数    
   let sendData = `
            <xml>
                <appid>${appid}</appid>
                <body>${body}</body>
                <mch_id>${mch_id}</mch_id>
                <nonce_str>${params.nonce_str}</nonce_str>
                <notify_url>${notify_url}</notify_url>
                <out_trade_no>${params.out_trade_no}</out_trade_no>
                <spbill_create_ip>${spbill_create_ip}</spbill_create_ip>
                <total_fee>${total_fee}</total_fee>
                <trade_type>${trade_type}</trade_type>
                <sign>${sign}</sign>
            </xml>
   `
    const data =  await createOrder(orderUrl, sendData);

    ctx.body = {
        status:200,
        data
    }
}
```

#### 4.总结

  我们使用微信支付时V2版本，请求参数和响应参数xml格式，xml是用于数据传输和存储数据用的，我们安装xml2js把响应的xml格式转成json





## 5.生成二维码

### 1.目标

 我们通过微信下单接口，拿到支付code_url  再去生成支付二维码

### 2.实现思路

1. 下载安装qrcode, 生成二维码图片(base64格式的图片)
2. 把二维码链接字符返回给客户端

   3.在浏览器地址栏中，输入base64图片地址，扫码支付

### 3.代码实现

controller/order.js

```javascript
const { default: axios } = require("axios")
const { createSign, getTrade_no,getRandomStr, createOrder } = require('../utils');
const {appid,mch_id,notify_url, orderUrl } = require('../config/wx');
const QRCode = require('qrcode');

// 微信下单
module.exports.order = async (ctx) =>{
    // 前端调用下单接口时传递的参数
    const { body,total_fee, spbill_create_ip,trade_type} = ctx.request.body;
    // 生成sign需要的参数
    const params = {
        appid,  
        mch_id,  // 商户号
        nonce_str: getRandomStr(), // 32位以内的随机字符串
        // sign, // 签名
        body, // 商品描述
        out_trade_no:getTrade_no(), // 商户订单号
        total_fee, // 金额
        spbill_create_ip,  // 终端ip
        notify_url, // 微信服务器回调的地址
        trade_type,  // 支付类型
    }

   // 生产签名  需要你发送的参数生成
   const sign =  createSign(params);
   //微信下单请求参数    
   let sendData = `
            <xml>
                <appid>${appid}</appid>
                <body>${body}</body>
                <mch_id>${mch_id}</mch_id>
                <nonce_str>${params.nonce_str}</nonce_str>
                <notify_url>${notify_url}</notify_url>
                <out_trade_no>${params.out_trade_no}</out_trade_no>
                <spbill_create_ip>${spbill_create_ip}</spbill_create_ip>
                <total_fee>${total_fee}</total_fee>
                <trade_type>${trade_type}</trade_type>
                <sign>${sign}</sign>
            </xml>
   `
    const data =  await createOrder(orderUrl, sendData);

    // 下单成功
    const { return_code, return_msg, result_code,code_url  } = data;
    if (return_code == 'SUCCESS' && return_msg == 'OK' && result_code == "SUCCESS") {
       data.payUrl =  await QRCode.toDataURL(code_url)
    }

    ctx.body = {
        status:200,
        data
    }
}
```

utils/index.js

```javascript
// 微信下单
module.exports.createOrder =(url, params) => {
    return new Promise(async (resolve, reject) => {
        const data = await axios({
            url,
            method: 'POST',
            data:params
        })
        // console.log(data.data, 'data');
        // resolve(data);
        xml.parseString(data.data, function (err, res){
             const {return_code,result_code,return_msg } = res.xml;
             if (  return_code == 'SUCCESS' && result_code == 'SUCCESS' && return_msg == 'OK' ) {
                 resolve(res.xml);
             }else {
                 reject(res);
             }
        })
    });
}
```



### 4.总结

我们调用微信的接口，给你返回code_url，它是给你用于生成支付二维码使用的，我们可以使用qrcode这个包，生成支付二维码，返回给前端



### 6.下单回调

### 1.目标

   我们调用微信下单接口时，返回code_url, 根据code_url使用qrcode生成支付二维码，用户扫码支付，支付之后商家要知道支付的结果，此时需要微信服务器调用你项目后端服务器的接口,这个接口时你提供，必须部署到服务器，必须要拥有域名， **所以我们自己实现一个接口，供微信服务器回调。**



### 2.实现思路

1. 按照mvc结果编译下单回调接口(结构实现，研究微信回调时，我们使用```ctx```可以拿到的请求)
2. 下载```koa-xml-body```包，在app.js 使用，就可以拿到微信回调的请求参数
3. 我们需要把下单回调结构部署到服务器

### 3.代码实现

routes/order.js

```javascript
//  微信下单回调
router.post('/pay/notify', notify);
```

controller/order.js

```javascript
// 微信下单通知
module.exports.notify = async (ctx) =>{
    // 打印微信服务器回调你的接口时的请求报文
    console.log(ctx.request.body);
}
```



#### 4.总结

下单回调接口需要部署到带有域名的服务器， 使用koa-xml-body解析微信回调的请求报文



## 6.创建订单表

### 1.目标

​    微信下单回调之后，我们需要把回调参数，写入到数据库订单表中，所有我们需要在服务器数据库中创建一个订单表。

#### 2.实现思路

1.   在服务器上创建数据库letaodb，创建一个订单表payorder

### 3.代码实现

```mysql
CREATE TABLE `payorder` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `appid` varchar(50) NOT NULL,
  `bank_type` varchar(50) NOT NULL,
  `cash_fee` varchar(50) NOT NULL,
  `fee_type` varchar(50) NOT NULL,
  `is_subscribe` varchar(50) NOT NULL,
  `mch_id` varchar(50) NOT NULL,
  `nonce_str` varchar(50) NOT NULL,
  `openid` varchar(50) NOT NULL,
  `out_trade_no` varchar(50) NOT NULL,
  `sign`varchar(50) NOT NULL,
  `time_end` varchar(50) NOT NULL,
  `total_fee` varchar(50) NOT NULL,
  `trade_type`  varchar(50) NOT NULL,
  `transaction_id` varchar(50) NOT NULL,
   PRIMARY KEY (`id`)
)
```

#### 4.总结

   下单回调，我们需要把订单写入到订单表中， 注册订单表要在服务中创建letaodb数据库,创建支付订单表payorder



## 7.订单表数据的写入

### 1.目标

​    微信下单回调后，需要把订单数据写入订单表

### 2.实现思路

1. 需要在请求上下文ctx中，结构出所有订单参数数据
2. 使用封装好的query方法，向订单表写入数据

### 3.代码实现

controller/order.js

```javascript
const { default: axios } = require("axios")
const { createSign, getTrade_no,getRandomStr, createOrder } = require('../utils');
const {appid,mch_id,notify_url, orderUrl } = require('../config/wx');
const QRCode = require('qrcode');
const { query } = require('../db/query');

// 微信下单通知
module.exports.notify = async (ctx) =>{
    // 打印微信服务器回调你的接口时的请求报文
    // console.log(ctx.request.body.xml);
    const { appid, bank_type,cash_fee,fee_type,is_subscribe,mch_id,nonce_str,openid,out_trade_no,sign,time_end,total_fee,trade_type,transaction_id } = ctx.request.body.xml;
   
    // 根据商户订单号查询支付订单表是否存在此订单
    const data = await query (`select * from payorder where out_trade_no = ?`, [out_trade_no]);
    if (data.length) return;  // 退出程序

    // await query(`insert into playorder (appid, bank_type,cash_fee,fee_type,is_subscribe,mch_id,nonce_str,openid,out_trade_no,sign,time_end,total_fee,trade_type,transaction_id) `)
    const result = await query(`insert into payorder(appid, bank_type,cash_fee,fee_type,is_subscribe,mch_id,nonce_str,openid,out_trade_no,sign,time_end,total_fee,trade_type,transaction_id) values('${appid}','${bank_type}','${cash_fee}','${fee_type}','${is_subscribe}','${mch_id}','${nonce_str}','${openid}','${out_trade_no}','${sign}','${time_end}','${total_fee}','${trade_type}','${transaction_id}')`);
    
    // 响应微信服务器接口，订单处理成功，无需重复通知
    ctx.body = `<xml>
    <return_code><![CDATA[SUCCESS]]></return_code>
    <return_msg><![CDATA[OK]]></return_msg>
  </xml>`
}
```

### 4.总结

微信下单后，回调通知会定时进行，所以在向订单表写数据前，先跟订单号查询订单表中是否存在此订单，是，退出，否，插入数据



















