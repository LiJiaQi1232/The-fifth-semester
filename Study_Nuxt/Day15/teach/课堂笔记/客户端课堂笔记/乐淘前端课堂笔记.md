## 乐淘前端

## 1.项目初始化

### 1.目标

​       完成乐淘前端项目初始化，前端项目的搭建，我们开发中一般使用脚手架完成，因为把基础设施都配置完毕，而且健壮的，经得起考验的，目标就是使用```nuxt```脚手架创建前端项目。

### 2.实现思路

1. yarn create  ```nuxt-app``` 项目名(英文， 而且不要写redux  react ``` vue`` 等)
2. cd 项目目录   && yarn dev 启动前端项目

### 3.总结

​     一般情况开发中直接使用脚手架创建前端项目

## 2.公共结构布局

### 1.目标

  我们使用布局文件，完成项目中上，中， 下结构拆分

### 2.实现思路

1. 创建```layouts/default.vue``` 默认布局文件,  拆分上中下三个结构
2. 中间变化的部分，使用<Nuxt /> 内置组件占位，路由匹配后显示对应页面组件
3. 使用```vant```组件, 插件的形式集成到```nuxt```前端项目, 在布局文件中完成上面标题和底部导航



### 3.代码实现

 ```vue
 <template>
   <div class="container">
     <!-- 1. 标题 -->
     <header>
       <van-nav-bar title="标题" left-text="返回" left-arrow>
         <template #right>
           <van-icon name="search" size="18" />
         </template>
       </van-nav-bar>
     </header>
     <!-- 2.主体 -->
     <main>
       <Nuxt />
     </main>
     <!-- 3.底部导航 -->
     <footer>
       <van-tabbar v-model="active">
         <van-tabbar-item icon="home-o">首页</van-tabbar-item>
         <van-tabbar-item icon="bag-o">分类</van-tabbar-item>
         <van-tabbar-item icon="shopping-cart-o">购物车</van-tabbar-item>
         <van-tabbar-item icon="friends-o">我的</van-tabbar-item>
       </van-tabbar>
     </footer>
   </div>
 </template>
 
 <script>
 export default {
   data() {
     return {
       active: 0,
     };
   },
 };
 </script>
 ```

#### 4.总结

使用```nuxt```做前端项目，公共布局一定在```layouts/xxx.vue ```来完成，  对于```vant  axios ```等等第三包，我们使用插件技术集成nuxt项目中， 在nuxt.config.js中做配置



## 3.公共布局文件优化

### 1.目标

   解决布局文件底部导航和头部标题，刷新页面高亮还原问题， 头部标题动态设置问题。 

### 2.实现思路

1.   给底部导航绑定name属性，name属性的值就是当点击的路由
2.  使用watch监听路由的变化，重新设置高亮



### 3.代码实现

layouts/default.vue

```vue
<template>
  <div class="container">
    <!-- 1. 标题 -->
    <header>
      <van-nav-bar :title="title" left-text="返回" left-arrow>
        <template #right>
          <van-icon name="search" size="18" />
        </template>
      </van-nav-bar>
    </header>
    <!-- 2.主体 -->
    <main>
      <Nuxt />
    </main>
    <!-- 3.底部导航 -->
    <footer>
      <van-tabbar v-model="active">
        <van-tabbar-item  name ="index" icon="home-o" to="/">首页</van-tabbar-item>
        <van-tabbar-item  name ="category" icon="bag-o" to="/category">分类</van-tabbar-item>
        <van-tabbar-item  name ="cart" icon="shopping-cart-o" to="/cart"
          >购物车</van-tabbar-item
        >
        <van-tabbar-item  name="my" icon="friends-o" to="/my">我的</van-tabbar-item>
      </van-tabbar>
    </footer>
  </div>
</template>

<script>
export default {
  data() {
    return {
      active: this.$route.name,  
      title: "",  // 空  原因是页面刷新有一个内容切换  所以默认为空
    };
  },

  methods: {
    // 刷新页面要设置标题
    refreshHandle() {
      this.title = {
        index: "乐淘-首页",
        category: "乐淘-分类",
        cart: "乐淘-购物车",
        my: "乐淘-我的",
      }[this.$route.name];
    },
  },

  // 刷新页面会触发mounted   asyncData 钩子只能在页面组件中使用
  mounted () {
      // 重新设置标题
      this.refreshHandle();
  },

  watch: {
    // 监听路由的变化
    $route() {
      console.log(this.$route);
      //  设置标题
      this.refreshHandle();
      //  设置高亮
    },
  },
};
</script>
```

### 4.总结

  watch监听路由时， 刷新页面不会触发，所以我们把它放到mounted钩子中，```vant ```底部导航组件需要设置name取值是路由， 在data中active的值直接读取路由名.

## 4.首页轮播图接口调用

### 1.目标

​       跨域概念，以及跨域解决

​			  前端调用后端接口时 协议，域名，端口，有其中一个不同，就是跨域， 解决跨域的方式： 1. 前端解决   2.后端解决  一般开发中在开发时都是前端解决，？？？  如果后端解决跨域了， 谁都可以调，从安全方面考虑，很多类似事情，前端需要做处理。

### 2.实现思路

1. 安装```@nuxtjs/axios ``` 
2. 我们以模块的方式集成```@nuxtjs/axios``` 在nuxt.config.js 中modules配置模块
3. 在页面组件中的```asyncData```中参数解构出```$axios```, 调用后端接口
4.  解决跨域， 前端配置代理解决跨域



### 3.代码实现

pages/index.vue

```vue
<template>
  <div class="home">首页</div>
</template>

<script>
export default {
    //  asyncData 刷新页面时，运行在服务端，服务器调用服务端接口不存在跨域
    //  跨域是浏览器端一种安全策略    解决浏览器端跨域
  async asyncData({ $axios }) {
    const  { swipperList }  = await $axios.$get("/api/banners");
    console.log(swipperList, 'swipperList');
    return {
        swipperList
    }
  },
};
</script>

```

#### 4.总结

  使用```@nuxt/proxy```模块解决跨域问题, 需要在```nuxt.config.s```中的```moudles```配置，```在axio配置中添加prxfix:'/api'```



## 5.后端解决跨域问题

### 1.目标

  我们在```koa```服务端项目解决跨域问题

### 2.实现思路

1. 使用yarn 安装```koa-cors```模块
2. 参照```npm```官方网站，把```koa-cors```中间件在```koa```项目中注册
3. 注释掉前端跨域，启用服务端跨域

### 3.代码实现

app.js

```javascript
const cors = require('koa-cors')

app.use(cors());
```



#### 4.总结

  我们使用```koa-cors```中间件解决```koa```后端跨域，开发中一般是前端解决跨域，前端解决跨域的手段细分：9种     1. proxy 2. ```nginx ``` 3. 浏览器设置强制跨域， 4. window   5. ```websocket```   



## 6.首页轮播图

### 1.目标

  完成首页轮播图的交互

### 2.实现思路

1.   使用```vant ui```库中的轮播图组件
2.  封装轮播图功能组件
3. 在首页中调用调用轮播图接口，拿到数据
4. 父子组件通信

### 3.代码实现

```pages/index.vue```

```vue
<template>
  <div class="home">
      <!-- 1.轮播图组件 -->
      <Carousel :swipperList="swipperList" />
  </div>
</template>

<script>
export default {
    //  asyncData 刷新页面时，运行在服务端，服务器调用服务端接口不存在跨域
    //  跨域是浏览器端一种安全策略    解决浏览器端跨域
  async asyncData({ $axios }) {
    // const  { swipperList }  = await $axios.$get("/banners");

    // 轮播图接口
    const  { swipperList }  = await $axios.$get("http://localhost:3000/banners");
    return {
        swipperList
    }
  },
};
</script>

```

```components/Carousel.vue```

```vue
<template>
  <van-swipe class="my-swipe" :autoplay="3000" indicator-color="white">
    <van-swipe-item v-for="item in swipperList" :key="item.id">
      <van-image :src="item.img_src" />
    </van-swipe-item>
  </van-swipe>
</template>

<script>
export default {
  props: ["swipperList"],
};
</script>
```

#### 4.总结

   static目录中的资源不会```webpack```打包，访问时直接相当于进入到了static , 相对于asset目录中的资源会被```webpack```打包，访问时使用'~/assets/....'



## 7.首页其他组件封装

### 1.目标

 完成首页中 宫格组件，  运动专区组件， 品牌组件  活动组件 静态功能组件的封装

### 2.实现思路

1. 在components/创建四个组件
2. 讲义中复制粘贴静态模块
3. 在首页中使用

### 3.代码实现

  pages/index.vue

```vue
<template>
  <div class="home">
      <!-- 1.轮播图组件 -->
      <IndexCarousel :swipperList="swipperList" />
      <!-- 2.宫格组件 -->
      <IndexGridList />
      <!-- 3.活动组件 -->
      <IndexActive />
      <!-- 4.品牌组件 -->
      <IndexBrand />
      <!-- 5.运动专区 -->
      <IndexSports />
  </div>
</template>

<script>
export default {
    //  asyncData 刷新页面时，运行在服务端，服务器调用服务端接口不存在跨域
    //  跨域是浏览器端一种安全策略    解决浏览器端跨域
  async asyncData({ $axios }) {
    // const  { swipperList }  = await $axios.$get("/banners");

    // 轮播图接口
    const  { swipperList }  = await $axios.$get("/banners");
    return {
        swipperList
    }
  },
};
</script>

```

components/IndexGridList.vue

```vue
<template>
  <div class="grid">
    <van-grid :border="false" :column-num="3">
      <van-grid-item>
        <van-image src="https://img01.yzcdn.cn/vant/apple-2.jpg" />
      </van-grid-item>
      <van-grid-item>
        <van-image src="https://img01.yzcdn.cn/vant/apple-3.jpg" />
      </van-grid-item>
      <van-grid-item>
        <van-image src="https://img01.yzcdn.cn/vant/apple-1.jpg" />
      </van-grid-item>
      <van-grid-item>
        <van-image src="https://img01.yzcdn.cn/vant/apple-2.jpg" />
      </van-grid-item>
      <van-grid-item>
        <van-image src="https://img01.yzcdn.cn/vant/apple-3.jpg" />
      </van-grid-item> 
    </van-grid>
  </div>
</template>
```



```components/IndexActive.vue```

```vue
<template>
  <div class="cz_active">
    <a href="#">
      <img src="images/active1.png" alt />
      <img src="images/active2.png" alt />
    </a>
    <a href="#">
      <img src="images/active3.png" alt />
    </a>
    <a href="#">
      <img src="images/active4.png" alt />
      <img src="images/active5.png" alt />
    </a>
  </div>
</template>

<style scoped>
.cz_active {
  border-top: 1px solid #ccc;
  margin-top: 15px;
  padding: 0 10px;
}
.cz_active a:nth-child(2n + 1) {
  width: 67.1%;
  float: left;
}
.cz_active a:nth-child(2n + 1) img {
  width: 50%;
  float: left;
}
.cz_active a:nth-child(2) {
  width: 32.9%;
  float: right;
}
.cz_active a:nth-child(2) img {
  width: 100%;
}
</style>
```



```components/IndexBrand.vue```

```vue
<template>
  <div class="cz_brand">
    <img src="images/title0.png" alt />
    <ul>
      <li>
        <a href="#">
          <img src="images/brand1.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand2.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand3.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand4.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand5.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand6.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand7.png" alt />
        </a>
      </li>
      <li>
        <a href="#">
          <img src="images/brand8.png" alt />
        </a>
      </li>
    </ul>
  </div>
</template>

<style scoped>
.cz_brand {
  padding: 0 10px;
}
.cz_brand > img {
  width: 100%;
}

.cz_brand ul {
  list-style: none;
  margin: 0;
  padding: 0;
}
.cz_brand ul li {
  width: 25%;
  float: left;
}
.cz_brand ul li a {
  display: block;
}
.cz_brand ul li a img {
  width: 100%;
}
</style>
```



```components/IndexSports.vue```

```vue
<template>
  <div class="cz_live">
    <img src="images/title1.png" alt="" />
    <div class="mui-clearfix">
      <a href="#" class="cz_product">
        <div class="box">
          <img src="/images/product.jpg" alt="" />
          <p class="name">adidas阿迪达斯 男式 场下休闲篮球鞋S83700</p>
          <p>
            <span class="price">¥560.00</span
            ><span class="oldPrice">¥888.00</span>
          </p>
          <button class="button">立即购买</button>
        </div>
      </a>
      <a href="#" class="cz_product">
        <div class="box">
          <img src="/images/product.jpg" alt="" />
          <p class="name">adidas阿迪达斯 男式 场下休闲篮球鞋S83700</p>
          <p>
            <span class="price">¥560.00</span
            ><span class="oldPrice">¥888.00</span>
          </p>
          <button class="button">立即购买</button>
        </div>
      </a>
      <a href="#" class="cz_product">
        <div class="box">
          <img src="images/product.jpg" alt="" />
          <p class="name">adidas阿迪达斯 男式 场下休闲篮球鞋S83700</p>
          <p>
            <span class="price">¥560.00</span
            ><span class="oldPrice">¥888.00</span>
          </p>
          <button class="button">立即购买</button>
        </div>
      </a>
      <a href="#" class="cz_product">
        <div class="box">
          <img src="images/product.jpg" alt="" />
          <p class="name">adidas阿迪达斯 男式 场下休闲篮球鞋S83700</p>
          <p>
            <span class="price">¥560.00</span
            ><span class="oldPrice">¥888.00</span>
          </p>
          <button class="button">立即购买</button>
        </div>
      </a>
    </div>
  </div>
</template>
<style scoped>
.cz_live {
  padding: 0 10px;
  margin-top: 10px;
  overflow: hidden;
  padding-bottom: 100px;
}
.cz_live > img {
  width: 100%;
}

.mui-clearfix:after {
  content: "020";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}

.mui-clearfix {
  /* 触发 hasLayout */
  zoom: 1;
}

.cz_product {
  float: left;
  width: 50%;
  padding: 0 5px;
  margin-bottom: 10px;
  box-sizing: border-box;
}
.cz_product .box {
  width: 100%;
  box-shadow: 0 0 5px #ccc;
  text-align: center;
  padding: 10px 0;
}
.cz_product .box img {
  width: 100%;
}
.cz_product .box .name {
  padding: 0 10px;
  height: 36px;
  line-height: 18px;
  overflow: hidden;
}
.cz_product .box .price {
  font-size: 12px;
  color: #f30;
  margin-right: 10px;
}
.cz_product .box .oldPrice {
  font-size: 12px;
  color: #ccc;
  text-decoration: line-through;
}
.cz_product .box .button {
  background: #006699;
  color: #fff;
}
</style>
```

#### 4.总结

1.  开发中流程是，产品会出原型设计稿， 到设计人员手上，此时前后端核心人员都要知道原型稿要做的大致功能，一起评估完成时间，以及是否能够实现

2.  有问题提前暴露，千万不要你能做，最后在说实现不了
3.  确定业务能走通，开工，  UI设计人员给设计稿->前端写静态页面还原设计稿，后端开始写接口. 
4. 前端静态页面完成，开始交互，调接口
5. 前后端联调
6. 测试人员介入， 过程不断提出bug，会有一个平台，里面是测试人员专门提bug， bug会指向具体开发人员
7. 相关人员，登录系统， 解决对应bug, 解决完bug，发布代码到uat，让测试人员核对是否解决？ 



## 7.首页中功能组件交互

### 1.目标

   先静后动， 静态页面完成后，我们要开始调接口写交互.

### 2.实现思路

1. 在首页中的```asyncData```钩子函数中参数解构出```$axios```块，调用对应的接口
2.  ```asyncData```返回从接口中读取需要的数据返回，会合并到data，页面中可以使用
3. 使用props解决父子组件通信
4. 在功能组件中拿到数据，渲染页面

### 3.代码实现

pages/index.vue

```vue
<template>
  <div class="home">
      <!-- 1.轮播图组件 -->
      <IndexCarousel :swipperList="swipperList" />
      <!-- 2.宫格组件 -->
      <IndexGridList :gridlist="gridlist"/>
      <!-- 3.活动组件 -->
      <IndexActive />
      <!-- 4.品牌组件 -->
      <IndexBrand />
      <!-- 5.运动专区 -->
      <IndexSports :sports="sports" />
  </div>
</template>

<script>
export default {
    //  asyncData 刷新页面时，运行在服务端，服务器调用服务端接口不存在跨域
    //  跨域是浏览器端一种安全策略    解决浏览器端跨域
  async asyncData({ $axios }) {
    // const  { swipperList }  = await $axios.$get("/banners");

    // 轮播图接口
    const  { swipperList }  = await $axios.$get("/banners");
    const  { gridlist }  = await $axios.$get("/gridlist");
    const  { sports }  = await $axios.$get("/sports");
    return {
        swipperList,
        gridlist,
        sports
    }
  },
};
</script>

```



### 4.总结

 父子通信使用props





























