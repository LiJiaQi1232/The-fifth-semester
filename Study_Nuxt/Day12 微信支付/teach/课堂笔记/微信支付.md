# 微信支付

## 1.下单结构代码

### 1.目标

​     我们在使用微信扫码支付时，需要调用微信的下单接口，把需要的参数需要我们提前处理，比如签名sign, 随机字符串, 完成了之后，我们可以拿到下单接口返回核心内容```code_url``，我们根据```code_url```生成一张支付的二维码，给前端.

### 2.实现思路

1.koa项目中使用```axios```调用微信下单接口

2.按照下单接口需要的参数，我们把结构写出来



### 3.代码实现

​	 routes/order.js

    ```javascript
    const router = require('koa-router')();
    
    const { order } = require('../controller/order');
    
    
    // 微信下单
    router.post('/order', order);
    
    
    module.exports = router;
    ```

controller/order.js

```javascript
const { default: axios } = require("axios")

// 微信下单
module.exports.order = async (ctx) =>{
    // 下单需要的参数
    const params = {
        appid,  
        mch_id,  // 商户号
        nonce_str, // 32位以内的随机字符串
        sign, // 签名
        body, // 商品描述
        out_trade_no, // 商户订单号
        total_fee, // 金额
        spbill_create_ip,  // 终端ip
        notify_url, // 微信服务器回调的地址
        trade_type,  // 支付类型
    }

    const data =  await createOrder(url, params);

    ctx.body = {
        status:200,
        data
    }
}
```



### 4.总结

1. 按照mvc结构新增order模块，在controller层调用微信下单， 把需要的参数准备好，下单单独在utils中封装一个下单方法



## 2.微信下单请求参数

### 1.目标

   我们需要把```appp_id, mch_id,  nonce_str```  下单其中三个参数搞定

### 2.实现思路

1. 为了安全考虑，把app_id, ```mch_id```  在后端存放
2. 在```utils```工具类中封装生成随机字符串的方法



### 3.代码实现

config/wx.js

```javascript
// appid
module.exports.app_id = 'wx8397f8696b538317';
// 商户号
module.exports.mch_id = '1473426802';



// 微信下单
module.exports.orderUrl = 'https://api.mch.weixin.qq.com/pay/unifiedorder';

```

utils/index.js

```javascript
// 生成32位以内的随机字符串,而且是不重复的
module.exports.getRandomStr = () =>{
 return  'letao' + this.getRandomByLength(6) + new Date().getTime();
}
```



### 4.总结

1. 较为敏感的数据，比如商户号，```appid```等这些数据，存放在后端,为了安全考虑，  要掌握随机数相关的操作，很多随机相关的业务，都基于随机数



## 3.签名算法

### 1.目标

我们需要按照微信下单接口中签名算法的要求，实现一个生成签名算法的方法。

### 2.实现思路

1. utils/index.js 封装一个```createSign ```方法 ，方法根据参数，返回一个32位的字符串
2. 需要拿到对象参数，拿到对象中的所有key按照数按照参数名ASCII码从小到大排序（字典序）
3. 返回字符串格式:   key1=value1&key2=value2…）拼接成字符串stringA。
4. 拿到拼接后的字符串 在拼接 key（商户后台）



### 3.代码实现

utils/index.js

```javascript
// 生成签名算法
module.exports.createSign = (args)=>{
    // 第一步，设所有发送或者接收到的数据为集合M，
    //  将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），
    // 使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。
    let stringA = '';
    Object.keys(args).sort().forEach(key => {
        stringA += `${key} = ${args[key]}&`;
    });

    stringA += `&key=${key}`;

    return crypto.createHash('MD5').update(stringA).digest('hex').toUpperCase()

}  
```



#### 4.总结

​      1.请求参数对象按照把所有的key 进行sort排序， 转成key1=value1 & key2 = value2........

​      2.最后的结果在拼接key(商户后台中的key)

​      3.  拿到最终字符串进行MD5加密(crypto)



## 4.微信下单

### 1.目标

​    我们按照微信下单官网文档，调通微信下单

### 2.实现思路

  1.定义变量，存放xml格式的请求参数

  2.utils/index.js  创建订单方法，返回的数据也是xml格式， 我需要安装xml2js接受返回的数据

  3.在controller/order.js 中 调用 下单方法，拿到数据返回给客户端



### 3.代码实现

utils/index.js

```javascript
// 微信下单
module.exports.createOrder =(url, params) => {
    return new Promise(async (resolve, reject) => {
        const data = await axios({
            url,
            method: 'POST',
            data:params
        })
        // console.log(data, 'data');
        // resolve(data);
        xml.parseString(data.data, function (err, data){
             resolve(data);
        })
    });
}
```

controller/order.js

```javascript
// 微信下单
module.exports.order = async (ctx) =>{
    // 前端调用下单接口时传递的参数
    const { body,total_fee, spbill_create_ip,trade_type} = ctx.request.body;
    // 生成sign需要的参数
    const params = {
        appid,  
        mch_id,  // 商户号
        nonce_str: getRandomStr(), // 32位以内的随机字符串
        // sign, // 签名
        body, // 商品描述
        out_trade_no:getTrade_no(), // 商户订单号
        total_fee, // 金额
        spbill_create_ip,  // 终端ip
        notify_url, // 微信服务器回调的地址
        trade_type,  // 支付类型
    }

   // 生产签名  需要你发送的参数生成
   const sign =  createSign(params);
   //微信下单请求参数    
   let sendData = `
            <xml>
                <appid>${appid}</appid>
                <body>${body}</body>
                <mch_id>${mch_id}</mch_id>
                <nonce_str>${params.nonce_str}</nonce_str>
                <notify_url>${notify_url}</notify_url>
                <out_trade_no>${params.out_trade_no}</out_trade_no>
                <spbill_create_ip>${spbill_create_ip}</spbill_create_ip>
                <total_fee>${total_fee}</total_fee>
                <trade_type>${trade_type}</trade_type>
                <sign>${sign}</sign>
            </xml>
   `
    const data =  await createOrder(orderUrl, sendData);

    ctx.body = {
        status:200,
        data
    }
}
```

#### 4.总结

  我们使用微信支付时V2版本，请求参数和响应参数xml格式，xml是用于数据传输和存储数据用的，我们安装xml2js把响应的xml格式转成json





## 5.生成二维码

### 1.目标

 我们通过微信下单接口，拿到支付code_url  再去生成支付二维码

### 2.实现思路

1. 下载安装qrcode, 生成二维码图片(base64格式的图片)
2. 把二维码链接字符返回给客户端

   3.在浏览器地址栏中，输入base64图片地址，扫码支付

### 3.代码实现

controller/order.js

```javascript
const { default: axios } = require("axios")
const { createSign, getTrade_no,getRandomStr, createOrder } = require('../utils');
const {appid,mch_id,notify_url, orderUrl } = require('../config/wx');
const QRCode = require('qrcode');

// 微信下单
module.exports.order = async (ctx) =>{
    // 前端调用下单接口时传递的参数
    const { body,total_fee, spbill_create_ip,trade_type} = ctx.request.body;
    // 生成sign需要的参数
    const params = {
        appid,  
        mch_id,  // 商户号
        nonce_str: getRandomStr(), // 32位以内的随机字符串
        // sign, // 签名
        body, // 商品描述
        out_trade_no:getTrade_no(), // 商户订单号
        total_fee, // 金额
        spbill_create_ip,  // 终端ip
        notify_url, // 微信服务器回调的地址
        trade_type,  // 支付类型
    }

   // 生产签名  需要你发送的参数生成
   const sign =  createSign(params);
   //微信下单请求参数    
   let sendData = `
            <xml>
                <appid>${appid}</appid>
                <body>${body}</body>
                <mch_id>${mch_id}</mch_id>
                <nonce_str>${params.nonce_str}</nonce_str>
                <notify_url>${notify_url}</notify_url>
                <out_trade_no>${params.out_trade_no}</out_trade_no>
                <spbill_create_ip>${spbill_create_ip}</spbill_create_ip>
                <total_fee>${total_fee}</total_fee>
                <trade_type>${trade_type}</trade_type>
                <sign>${sign}</sign>
            </xml>
   `
    const data =  await createOrder(orderUrl, sendData);

    // 下单成功
    const { return_code, return_msg, result_code,code_url  } = data;
    if (return_code == 'SUCCESS' && return_msg == 'OK' && result_code == "SUCCESS") {
       data.payUrl =  await QRCode.toDataURL(code_url)
    }

    ctx.body = {
        status:200,
        data
    }
}
```

utils/index.js

```javascript
// 微信下单
module.exports.createOrder =(url, params) => {
    return new Promise(async (resolve, reject) => {
        const data = await axios({
            url,
            method: 'POST',
            data:params
        })
        // console.log(data.data, 'data');
        // resolve(data);
        xml.parseString(data.data, function (err, res){
             const {return_code,result_code,return_msg } = res.xml;
             if (  return_code == 'SUCCESS' && result_code == 'SUCCESS' && return_msg == 'OK' ) {
                 resolve(res.xml);
             }else {
                 reject(res);
             }
        })
    });
}
```



### 4.总结

我们调用微信的接口，给你返回code_url，它是给你用于生成支付二维码使用的，我们可以使用qrcode这个包，生成支付二维码，返回给前端



















